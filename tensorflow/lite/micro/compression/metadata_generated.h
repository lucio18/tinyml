// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_METADATA_TFLITE_MICRO_COMPRESSION_H_
#define FLATBUFFERS_GENERATED_METADATA_TFLITE_MICRO_COMPRESSION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace tflite {
namespace micro {
namespace compression {

struct Metadata;
struct MetadataBuilder;

struct Subgraph;
struct SubgraphBuilder;

struct LutTensor;
struct LutTensorBuilder;

struct Metadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBGRAPHS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>> *subgraphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>> *>(VT_SUBGRAPHS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           verifier.EndTable();
  }
};

struct MetadataBuilder {
  typedef Metadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subgraphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>>> subgraphs) {
    fbb_.AddOffset(Metadata::VT_SUBGRAPHS, subgraphs);
  }
  explicit MetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Metadata> CreateMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>>> subgraphs = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_subgraphs(subgraphs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Metadata> CreateMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>> *subgraphs = nullptr) {
  auto subgraphs__ = subgraphs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>>(*subgraphs) : 0;
  return tflite::micro::compression::CreateMetadata(
      _fbb,
      subgraphs__);
}

struct Subgraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubgraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LUT_TENSORS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>> *lut_tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>> *>(VT_LUT_TENSORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LUT_TENSORS) &&
           verifier.VerifyVector(lut_tensors()) &&
           verifier.VerifyVectorOfTables(lut_tensors()) &&
           verifier.EndTable();
  }
};

struct SubgraphBuilder {
  typedef Subgraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lut_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>>> lut_tensors) {
    fbb_.AddOffset(Subgraph::VT_LUT_TENSORS, lut_tensors);
  }
  explicit SubgraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Subgraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Subgraph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Subgraph> CreateSubgraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>>> lut_tensors = 0) {
  SubgraphBuilder builder_(_fbb);
  builder_.add_lut_tensors(lut_tensors);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Subgraph> CreateSubgraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>> *lut_tensors = nullptr) {
  auto lut_tensors__ = lut_tensors ? _fbb.CreateVector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>>(*lut_tensors) : 0;
  return tflite::micro::compression::CreateSubgraph(
      _fbb,
      lut_tensors__);
}

struct LutTensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LutTensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR = 4,
    VT_VALUE_BUFFER = 6,
    VT_INDEX_BITWIDTH = 8
  };
  int32_t tensor() const {
    return GetField<int32_t>(VT_TENSOR, 0);
  }
  uint32_t value_buffer() const {
    return GetField<uint32_t>(VT_VALUE_BUFFER, 0);
  }
  uint8_t index_bitwidth() const {
    return GetField<uint8_t>(VT_INDEX_BITWIDTH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TENSOR, 4) &&
           VerifyField<uint32_t>(verifier, VT_VALUE_BUFFER, 4) &&
           VerifyField<uint8_t>(verifier, VT_INDEX_BITWIDTH, 1) &&
           verifier.EndTable();
  }
};

struct LutTensorBuilder {
  typedef LutTensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tensor(int32_t tensor) {
    fbb_.AddElement<int32_t>(LutTensor::VT_TENSOR, tensor, 0);
  }
  void add_value_buffer(uint32_t value_buffer) {
    fbb_.AddElement<uint32_t>(LutTensor::VT_VALUE_BUFFER, value_buffer, 0);
  }
  void add_index_bitwidth(uint8_t index_bitwidth) {
    fbb_.AddElement<uint8_t>(LutTensor::VT_INDEX_BITWIDTH, index_bitwidth, 0);
  }
  explicit LutTensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LutTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LutTensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LutTensor> CreateLutTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tensor = 0,
    uint32_t value_buffer = 0,
    uint8_t index_bitwidth = 0) {
  LutTensorBuilder builder_(_fbb);
  builder_.add_value_buffer(value_buffer);
  builder_.add_tensor(tensor);
  builder_.add_index_bitwidth(index_bitwidth);
  return builder_.Finish();
}

inline const tflite::micro::compression::Metadata *GetMetadata(const void *buf) {
  return ::flatbuffers::GetRoot<tflite::micro::compression::Metadata>(buf);
}

inline const tflite::micro::compression::Metadata *GetSizePrefixedMetadata(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<tflite::micro::compression::Metadata>(buf);
}

inline bool VerifyMetadataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::micro::compression::Metadata>(nullptr);
}

inline bool VerifySizePrefixedMetadataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::micro::compression::Metadata>(nullptr);
}

inline void FinishMetadataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::micro::compression::Metadata> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMetadataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::micro::compression::Metadata> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace compression
}  // namespace micro
}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_METADATA_TFLITE_MICRO_COMPRESSION_H_
